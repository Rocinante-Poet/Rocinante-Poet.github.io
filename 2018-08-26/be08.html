<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-flash.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />





  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "57a36a3c"
    });
  daovoice('update');
  </script>















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/poetry-128.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/poetry-64.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/poetry-32.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C#,线程," />










<meta name="description" content="基本概念 进程（Process）是Windows系统中的一个基本概念，它包含着一个运行程序所需要的资源。一个正在运行的应用程序在操作系统中被视为一个进程，进程可以包括一个或多个线程。线程是操作系统分配处理器时间的基本单元，在进程中可以有多个线程同时执行代码。进程之间是相对独立的，一个进程无法访问另一个进程的数据（除非利用分布式计算方式），一个进程运行的失败也不会影响其他进程的运行，Windows系">
<meta name="keywords" content="C#,线程">
<meta property="og:type" content="article">
<meta property="og:title" content="Thread 线程">
<meta property="og:url" content="https://rocinante-poet.github.io/2018-08-26/be08.html">
<meta property="og:site_name" content="Poet">
<meta property="og:description" content="基本概念 进程（Process）是Windows系统中的一个基本概念，它包含着一个运行程序所需要的资源。一个正在运行的应用程序在操作系统中被视为一个进程，进程可以包括一个或多个线程。线程是操作系统分配处理器时间的基本单元，在进程中可以有多个线程同时执行代码。进程之间是相对独立的，一个进程无法访问另一个进程的数据（除非利用分布式计算方式），一个进程运行的失败也不会影响其他进程的运行，Windows系">
<meta property="og:locale" content="zh-hans">
<meta property="og:image" content="https://rocinante-poet.github.io/2018-08-26/be08/1-1.PNG">
<meta property="og:image" content="https://rocinante-poet.github.io/2018-08-26/be08/1-2.PNG">
<meta property="og:image" content="https://rocinante-poet.github.io/2018-08-26/be08/2.1-1.JPG">
<meta property="og:image" content="https://rocinante-poet.github.io/2018-08-26/be08/2.1-2.JPG">
<meta property="og:image" content="https://rocinante-poet.github.io/2018-08-26/be08/2.13.JPG">
<meta property="og:image" content="https://rocinante-poet.github.io/2018-08-26/be08/2.14.JPG">
<meta property="og:image" content="https://rocinante-poet.github.io/2018-08-26/be08/2.2.41.JPG">
<meta property="og:image" content="https://rocinante-poet.github.io/2018-08-26/be08/2.51.JPG">
<meta property="og:image" content="https://rocinante-poet.github.io/2018-08-26/be08/31.JPG">
<meta property="og:image" content="https://rocinante-poet.github.io/2018-08-26/be08/32.JPG">
<meta property="og:image" content="https://rocinante-poet.github.io/2018-08-26/be08/33.JPG">
<meta property="og:image" content="https://rocinante-poet.github.io/2018-08-26/be08/41.JPG">
<meta property="og:image" content="https://rocinante-poet.github.io/2018-08-26/be08/42.JPG">
<meta property="og:image" content="https://rocinante-poet.github.io/2018-08-26/be08/43.JPG">
<meta property="og:image" content="https://rocinante-poet.github.io/2018-08-26/be08/44.JPG">
<meta property="og:image" content="https://rocinante-poet.github.io/2018-08-26/be08/45.JPG">
<meta property="og:updated_time" content="2018-09-05T04:48:34.394Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Thread 线程">
<meta name="twitter:description" content="基本概念 进程（Process）是Windows系统中的一个基本概念，它包含着一个运行程序所需要的资源。一个正在运行的应用程序在操作系统中被视为一个进程，进程可以包括一个或多个线程。线程是操作系统分配处理器时间的基本单元，在进程中可以有多个线程同时执行代码。进程之间是相对独立的，一个进程无法访问另一个进程的数据（除非利用分布式计算方式），一个进程运行的失败也不会影响其他进程的运行，Windows系">
<meta name="twitter:image" content="https://rocinante-poet.github.io/2018-08-26/be08/1-1.PNG">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://rocinante-poet.github.io/2018-08-26/be08.html"/>





  <title>Thread 线程,Poet-蔚然成凨</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Poet</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">蔚然成凨</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于|留言
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-links">
          <a href="/links/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-link"></i> <br />
            
            链接
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rocinante-poet.github.io/2018-08-26/be08.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocinante-Poet">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/poet.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Poet">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Thread 线程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-26T14:45:47+08:00">
                2018-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C#</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><br></p>
<p><font color="#FA8072"><strong>进程（Process）是Windows系统中的一个基本概念，它包含着一个运行程序所需要的资源。一个正在运行的应用程序在操作系统中被视为一个进程，进程可以包括一个或多个线程。线程是操作系统分配处理器时间的基本单元，在进程中可以有多个线程同时执行代码。进程之间是相对独立的，一个进程无法访问另一个进程的数据（除非利用分布式计算方式），一个进程运行的失败也不会影响其他进程的运行，Windows系统就是利用进程把工作划分为多个独立的区域的。进程可以理解为一个程序的基本边界。是应用程序的一个运行例程，是应用程序的一次动态执行过程。</strong></font>   <br></p>
<p><font color="#00CED1"><strong>线程（Thread）是进程中的基本执行单元，是操作系统分配CPU时间的基本单位，一个进程可以包含若干个线程，在进程入口执行的第一个线程被视为这个进程的主线程。在.NET应用程序中，都是以Main()方法作为入口的，当调用此方法时系统就会自动创建一个主线程。线程主要是由CPU寄存器、调用栈和线程本地存储器（Thread Local Storage，TLS）组成的。CPU寄存器主要记录当前所执行线程的状态，调用栈主要用于维护线程所调用到的内存与数据，TLS主要用于存放线程的状态信息。</strong></font><br><a id="more"></a></p>
<p><strong>进程：</strong></p>
<img src="/2018-08-26/be08/1-1.PNG" title="任务管理器中的进程">
<p><strong>线程：</strong></p>
<img src="/2018-08-26/be08/1-2.PNG" title="任务管理器中总共运行的线程数">
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>多线程的优点：可以同时完成多个任务；可以使程序的响应速度更快；可以让占用大量处理时间的任务或当前没有进行处理的任务定期将处理时间让给别的任务；可以随时停止任务；可以设置每个任务的优先级以优化程序性能。</p>
<p>那么可能有人会问：为什么可以多线程执行呢？总结起来有下面两方面的原因：</p>
<ol>
<li>CPU运行速度太快，硬件处理速度跟不上，所以操作系统进行分时间片管理。这样，从宏观角度来说是多线程并发的，因为CPU速度太快，察觉不到，看起来是同一时刻执行了不同的操作。但是从微观角度来讲，同一时刻只能有一个线程在处理。  </li>
<li>目前电脑都是多核多CPU的，一个CPU在同一时刻只能运行一个线程，但是多个CPU在同一时刻就可以运行多个线程。</li>
</ol>
<p>然而，多线程虽然有很多优点，但是也必须认识到多线程可能存在影响系统性能的不利方面，才能正确使用线程。不利方面主要有如下几点：</p>
<ul>
<li>线程也是程序，所以线程需要占用内存，线程越多，占用内存也越多。</li>
<li>多线程需要协调和管理，所以需要占用CPU时间以便跟踪线程。</li>
<li>线程之间对共享资源的访问会相互影响，必须解决争用共享资源的问题。</li>
<li>线程太多会导致控制太复杂，最终可能造成很多程序缺陷。</li>
</ul>
<p>当启动一个可执行程序时，将创建一个主线程。在默认的情况下，C#程序具有一个线程，此线程执行程序中以Main方法开始和结束的代码，Main（）直接或间接执行的每一个命令都有默认线程（主线程）执行，当Main（）方法返回时此线程也将终止。</p>
<p>一个进程可以创建一个或多个线程以执行与该进程关联的部分程序代码。在C#中，线程是使用Thread类处理的，该类在System.Threading命名空间中。使用Thread类创建线程时，只需要提供线程入口，线程入口告诉程序让这个线程做什么。通过实例化一个Thread类的对象就可以创建一个线程。创建新的Thread对象时，将创建新的托管线程。Thread类接收一个ThreadStart委托或ParameterizedThreadStart委托的构造函数，该委托包装了调用Start方法时由新线程调用的方法，示例代码如下：</p>
<pre><code>Thread thread=new Thread(new ThreadStart(A));   //创建线程
thread.Start();                                 //启动线程
</code></pre><p>上面代码实例化了一个Thread对象，并指明将要调用的方法A()，然后启动线程。ThreadStart委托中作为参数的方法不需要参数，并且没有返回值。ParameterizedThreadStart委托一个对象作为参数，利用这个参数可以很方便地向线程传递参数，示例代码如下：</p>
<pre><code>Thread thread=new Thread(new ParameterizedThreadStart(A));  //创建线程
thread.Start(3);                                            //启动线程
</code></pre><p>创建多线程的步骤：</p>
<ol>
<li>编写线程所要执行的方法</li>
<li>实例化Thread类，并传入一个指向线程所要执行方法的委托。（这时线程已经产生，但还没有运行）</li>
<li>调用Thread实例的Start方法，标记该线程可以被CPU执行了，但具体执行时间由CPU决定</li>
</ol>
<h2 id="System-Threading-Thread类"><a href="#System-Threading-Thread类" class="headerlink" title="System.Threading.Thread类"></a>System.Threading.Thread类</h2><p>Thread类是是控制线程的基础类，位于System.Threading命名空间下，具有4个重载的构造函数：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Thread(ParameterizedThreadStart)</td>
<td style="text-align:center">初始化 Thread 类的新实例，指定允许对象在线程启动时传递给线程的委托。要执行的方法是有参的。</td>
</tr>
<tr>
<td style="text-align:center">Thread(ParameterizedThreadStart, Int32)</td>
<td style="text-align:center">初始化 Thread 类的新实例，指定允许对象在线程启动时传递给线程的委托，并指定线程的最大堆栈大小。</td>
</tr>
<tr>
<td style="text-align:center">Thread(ThreadStart)</td>
<td style="text-align:center">初始化 Thread 类的新实例。要执行的方法是无参的。</td>
</tr>
<tr>
<td style="text-align:center">Thread(ThreadStart, Int32)</td>
<td style="text-align:center">初始化 Thread 类的新实例，指定线程的最大堆栈大小。</td>
</tr>
</tbody>
</table>
<p>ThreadStart是一个无参的、返回值为void的委托。委托定义如下：</p>
<p>public delegate void ThreadStart()</p>
<p>通过ThreadStart委托创建并运行一个线程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        //创建无参的线程</span><br><span class="line">        Thread thread = new Thread(new ThreadStart(A));</span><br><span class="line">        thread1.Start();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 创建无参的方法</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    static void A()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;这是无参的方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2018-08-26/be08/2.1-1.JPG" title="运行结果">
<p>除了可以运行静态的方法，还可以运行实例方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        //创建ThreadTest类的一个实例</span><br><span class="line">        ThreadTest test=new ThreadTest();</span><br><span class="line">        //调用test实例的MyThread方法</span><br><span class="line">        Thread thread = new Thread(new ThreadStart(test.MyThread));</span><br><span class="line">        //启动线程</span><br><span class="line">        thread.Start();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ThreadTest</span><br><span class="line">&#123;</span><br><span class="line">    public void MyThread()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;这是一个实例方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2018-08-26/be08/2.1-2.JPG" title="运行结果">
<p>如果为了简单，也可以通过匿名委托或Lambda表达式来为Thread的构造方法赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">      //通过匿名委托创建</span><br><span class="line">      Thread thread1 = new Thread(delegate() &#123; Console.WriteLine(&quot;我是通过匿名委托创建的线程&quot;); &#125;);</span><br><span class="line">      thread1.Start();</span><br><span class="line">      //通过Lambda表达式创建</span><br><span class="line">      Thread thread2 = new Thread(() =&gt; Console.WriteLine(&quot;我是通过Lambda表达式创建的委托&quot;));</span><br><span class="line">      thread2.Start();</span><br><span class="line">      Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2018-08-26/be08/2.13.JPG" title="运行结果">
<p>ParameterizedThreadStart是一个有参的、返回值为void的委托，定义如下：<br>public delegate void ParameterizedThreadStart(Object obj)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            //通过ParameterizedThreadStart创建线程</span><br><span class="line">            Thread thread = new Thread(new ParameterizedThreadStart(Thread1));</span><br><span class="line">            //给方法传值</span><br><span class="line">            thread.Start(&quot;这是一个有参数的委托&quot;);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 创建有参的方法</span><br><span class="line">        /// 注意：方法里面的参数类型必须是Object类型</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;obj&quot;&gt;&lt;/param&gt;</span><br><span class="line">        static void Thread1(object obj)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：ParameterizedThreadStart委托的参数类型必须是Object的。如果使用的是不带参数的委托，不能使用带参数的Start方法运行线程，否则系统会抛出异常。但使用带参数的委托，可以使用thread.Start()来运行线程，这时所传递的参数值为null。</p>
</blockquote>
<img src="/2018-08-26/be08/2.14.JPG" title="运行结果">
<h2 id="线程的常用属性"><a href="#线程的常用属性" class="headerlink" title="线程的常用属性"></a>线程的常用属性</h2><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CurrentContext</td>
<td style="text-align:center">获取线程正在其中执行的当前上下文。</td>
</tr>
<tr>
<td style="text-align:center">CurrentThread</td>
<td style="text-align:center">获取当前正在运行的线程。</td>
</tr>
<tr>
<td style="text-align:center">ExecutionContext</td>
<td style="text-align:center">获取一个 ExecutionContext 对象，该对象包含有关当前线程的各种上下文的信息。</td>
</tr>
<tr>
<td style="text-align:center">IsAlive</td>
<td style="text-align:center">获取一个值，该值指示当前线程的执行状态。</td>
</tr>
<tr>
<td style="text-align:center">IsBackground</td>
<td style="text-align:center">获取或设置一个值，该值指示某个线程是否为后台线程。</td>
</tr>
<tr>
<td style="text-align:center">IsThreadPoolThread</td>
<td style="text-align:center">获取一个值，该值指示线程是否属于托管线程池。</td>
</tr>
<tr>
<td style="text-align:center">ManagedThreadId</td>
<td style="text-align:center">获取当前托管线程的唯一标识符。</td>
</tr>
<tr>
<td style="text-align:center">Name</td>
<td style="text-align:center">获取或设置线程的名称。</td>
</tr>
<tr>
<td style="text-align:center">Priority</td>
<td style="text-align:center">获取或设置一个值，该值指示线程的调度优先级。</td>
</tr>
<tr>
<td style="text-align:center">ThreadState</td>
<td style="text-align:center">获取一个值，该值包含当前线程的状态。</td>
</tr>
</tbody>
</table>
<h3 id="线程的标识符"><a href="#线程的标识符" class="headerlink" title="线程的标识符"></a>线程的标识符</h3><p>ManagedThreadId是确认线程的唯一标识符，程序在大部分情况下都是通过Thread.ManagedThreadId来辨别线程的。而Name是一个可变值，在默认时候，Name为一个空值 Null，开发人员可以通过程序设置线程的名称，但这只是一个辅助功能。</p>
<h3 id="线程的优先级别"><a href="#线程的优先级别" class="headerlink" title="线程的优先级别"></a>线程的优先级别</h3><p>当线程之间争夺CPU时间时，CPU按照线程的优先级给予服务。高优先级的线程可以完全阻止低优先级的线程执行。.NET为线程设置了Priority属性来定义线程执行的优先级别，里面包含5个选项，其中Normal是默认值。除非系统有特殊要求，否则不应该随便设置线程的优先级别。</p>
<table>
<thead>
<tr>
<th style="text-align:center">成员名称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Lowest</td>
<td style="text-align:center">可以将 Thread 安排在具有任何其他优先级的线程之后。</td>
</tr>
<tr>
<td style="text-align:center">BelowNormal</td>
<td style="text-align:center">可以将 Thread 安排在具有 Normal 优先级的线程之后，在具有 Lowest 优先级的线程之前。</td>
</tr>
<tr>
<td style="text-align:center">Normal</td>
<td style="text-align:center">默认选择。可以将 Thread 安排在具有 AboveNormal 优先级的线程之后，在具有 BelowNormal 优先级的线程之前。</td>
</tr>
<tr>
<td style="text-align:center">AboveNormal</td>
<td style="text-align:center">可以将 Thread 安排在具有 Highest 优先级的线程之后，在具有 Normal 优先级的线程之前。</td>
</tr>
<tr>
<td style="text-align:center">Highest</td>
<td style="text-align:center">可以将 Thread 安排在具有任何其他优先级的线程之前。</td>
</tr>
</tbody>
</table>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>通过ThreadState可以检测线程是处于Unstarted、Sleeping、Running 等等状态，它比 IsAlive 属性能提供更多的特定信息。</p>
<p>前面说过，一个应用程序域中可能包括多个上下文，而通过CurrentContext可以获取线程当前的上下文。</p>
<p>CurrentThread是最常用的一个属性，它是用于获取当前运行的线程。</p>
<h3 id="System-Threading-Thread的方法"><a href="#System-Threading-Thread的方法" class="headerlink" title="System.Threading.Thread的方法"></a>System.Threading.Thread的方法</h3><p>Thread 中包括了多个方法来控制线程的创建、挂起、停止、销毁，以后来的例子中会经常使用。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">GetDomain()</td>
<td style="text-align:center">返回当前线程正在其中运行的当前域。</td>
</tr>
<tr>
<td style="text-align:center">GetDomainId()</td>
<td style="text-align:center">返回当前线程正在其中运行的当前域Id。</td>
</tr>
<tr>
<td style="text-align:center">Interrupt()</td>
<td style="text-align:center">中断处于 WaitSleepJoin 线程状态的线程。</td>
</tr>
<tr>
<td style="text-align:center">Join()</td>
<td style="text-align:center">已重载。 阻塞调用线程，直到某个线程终止时为止。</td>
</tr>
<tr>
<td style="text-align:center">Resume()</td>
<td style="text-align:center">继续运行已挂起的线程。</td>
</tr>
<tr>
<td style="text-align:center">Start()</td>
<td style="text-align:center">　　    执行本线程。</td>
</tr>
<tr>
<td style="text-align:center">Suspend()</td>
<td style="text-align:center">挂起当前线程，如果当前线程已属于挂起状态则此不起作用</td>
</tr>
<tr>
<td style="text-align:center">Sleep()</td>
<td style="text-align:center">　　    把正在运行的线程挂起一段时间。</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            //获取正在运行的线程</span><br><span class="line">            Thread thread = Thread.CurrentThread;</span><br><span class="line">            //设置线程的名字</span><br><span class="line">            thread.Name = &quot;主线程&quot;;</span><br><span class="line">            //获取当前线程的唯一标识符</span><br><span class="line">            int id = thread.ManagedThreadId;</span><br><span class="line">            //获取当前线程的状态</span><br><span class="line">            ThreadState state= thread.ThreadState;</span><br><span class="line">            //获取当前线程的优先级</span><br><span class="line">            ThreadPriority priority= thread.Priority;</span><br><span class="line">            string strMsg = string.Format(&quot;Thread ID:&#123;0&#125;\n&quot; + &quot;Thread Name:&#123;1&#125;\n&quot; +</span><br><span class="line">                &quot;Thread State:&#123;2&#125;\n&quot; + &quot;Thread Priority:&#123;3&#125;\n&quot;, id, thread.Name,</span><br><span class="line">                state, priority);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(strMsg);</span><br><span class="line">                      </span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<img src="/2018-08-26/be08/2.2.41.JPG" title="运行结果">
<h2 id="前台线程和后台线程"><a href="#前台线程和后台线程" class="headerlink" title="前台线程和后台线程"></a>前台线程和后台线程</h2><p>前台线程：只有所有的前台线程都结束，应用程序才能结束。默认情况下创建的线程<br>              都是前台线程<br>后台线程：只要所有的前台线程结束，后台线程自动结束。通过Thread.IsBackground设置后台线程。必须在调用Start方法之前设置线程的类型，否则一旦线程运行，将无法改变其类型。</p>
<p>通过BeginXXX方法运行的线程都是后台线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;                   </span><br><span class="line">            //演示前台、后台线程</span><br><span class="line">            BackGroundTest background = new BackGroundTest(10);</span><br><span class="line">            //创建前台线程</span><br><span class="line">            Thread fThread = new Thread(new ThreadStart(background.RunLoop));</span><br><span class="line">            //给线程命名</span><br><span class="line">            fThread.Name = &quot;前台线程&quot;;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            BackGroundTest background1 = new BackGroundTest(20);</span><br><span class="line">            //创建后台线程</span><br><span class="line">            Thread bThread = new Thread(new ThreadStart(background1.RunLoop));</span><br><span class="line">            bThread.Name = &quot;后台线程&quot;;</span><br><span class="line">            //设置为后台线程</span><br><span class="line">            bThread.IsBackground = true;</span><br><span class="line"></span><br><span class="line">            //启动线程</span><br><span class="line">            fThread.Start();</span><br><span class="line">            bThread.Start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class BackGroundTest</span><br><span class="line">    &#123;</span><br><span class="line">        private int Count;</span><br><span class="line">        public BackGroundTest(int count)</span><br><span class="line">        &#123;</span><br><span class="line">            this.Count = count;</span><br><span class="line">        &#125;</span><br><span class="line">        public void RunLoop()</span><br><span class="line">        &#123;</span><br><span class="line">            //获取当前线程的名称</span><br><span class="line">            string threadName = Thread.CurrentThread.Name;</span><br><span class="line">            for (int i = 0; i &lt; Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;&#123;0&#125;计数：&#123;1&#125;&quot;,threadName,i.ToString());</span><br><span class="line">                //线程休眠500毫秒</span><br><span class="line">                Thread.Sleep(1000);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;&#123;0&#125;完成计数&quot;,threadName);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果：前台线程执行完，后台线程未执行完，程序自动结束。  </p>
</blockquote>
<blockquote>
<p>把bThread.IsBackground = true注释掉<br>运行结果：主线程执行完毕后(Main函数)，程序并未结束，而是要等所有的前台线程结束以后才会结束。</p>
</blockquote>
<blockquote>
<p>后台线程一般用于处理不重要的事情，应用程序结束时，后台线程是否执行完成对整个应用程序没有影响。如果要执行的事情很重要，需要将线程设置为前台线程。</p>
</blockquote>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>所谓同步：是指在某一时刻只有一个线程可以访问变量。<br>如果不能确保对变量的访问是同步的，就会产生错误。<br>c#为同步访问变量提供了一个非常简单的方式，即使用c#语言的关键字Lock，它可以把一段代码定义为互斥段，互斥段在一个时刻内只允许一个线程进入执行，而其他线程必须等待。在c#中，关键字Lock定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Lock(expression)</span><br><span class="line">&#123;</span><br><span class="line">   statement_block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>expression代表你希望跟踪的对象：<br>           如果你想保护一个类的实例，一般地，你可以使用this；<br>           如果你想保护一个静态变量（如互斥代码段在一个静态方法内部），一般使用类名就可以了<br>而statement_block就算互斥段的代码，这段代码在一个时刻内只可能被一个线程执行。</p>
<p>以书店卖书为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;                   </span><br><span class="line">            BookShop book = new BookShop();</span><br><span class="line">            //创建两个线程同时访问Sale方法</span><br><span class="line">            Thread t1 = new Thread(new ThreadStart(book.Sale));</span><br><span class="line">            Thread t2 = new Thread(new ThreadStart(book.Sale));</span><br><span class="line">            //启动线程</span><br><span class="line">            t1.Start();</span><br><span class="line">            t2.Start();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class BookShop</span><br><span class="line">    &#123;</span><br><span class="line">        //剩余图书数量</span><br><span class="line">        public int num = 1;</span><br><span class="line">        public void Sale()</span><br><span class="line">        &#123;</span><br><span class="line">            int tmp = num;</span><br><span class="line">            if (tmp &gt; 0)//判断是否有书，如果有就可以卖</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.Sleep(1000);</span><br><span class="line">                num -= 1;</span><br><span class="line">                Console.WriteLine(&quot;售出一本图书，还剩余&#123;0&#125;本&quot;, num);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;没有了&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果：<br>售出一本图书，还剩余0本<br>售出一本图书，还剩余-1本</p>
</blockquote>
<p>从运行结果可以看出，两个线程同步访问共享资源，没有考虑同步的问题，结果不正确。</p>
<p>考虑线程同步，改进后的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;                   </span><br><span class="line">            BookShop book = new BookShop();</span><br><span class="line">            //创建两个线程同时访问Sale方法</span><br><span class="line">            Thread t1 = new Thread(new ThreadStart(book.Sale));</span><br><span class="line">            Thread t2 = new Thread(new ThreadStart(book.Sale));</span><br><span class="line">            //启动线程</span><br><span class="line">            t1.Start();</span><br><span class="line">            t2.Start();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class BookShop</span><br><span class="line">    &#123;</span><br><span class="line">        //剩余图书数量</span><br><span class="line">        public int num = 1;</span><br><span class="line">        public void Sale()</span><br><span class="line">        &#123;</span><br><span class="line">            //使用lock关键字解决线程同步问题</span><br><span class="line">            lock (this)</span><br><span class="line">            &#123;</span><br><span class="line">                int tmp = num;</span><br><span class="line">                if (tmp &gt; 0)//判断是否有书，如果有就可以卖</span><br><span class="line">                &#123;</span><br><span class="line">                    Thread.Sleep(1000);</span><br><span class="line">                    num -= 1;</span><br><span class="line">                    Console.WriteLine(&quot;售出一本图书，还剩余&#123;0&#125;本&quot;, num);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;没有了&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果：<br>售出一本图书，还剩余0本<br>没有了</p>
</blockquote>
<h2 id="跨线程访问"><a href="#跨线程访问" class="headerlink" title="跨线程访问"></a>跨线程访问</h2><p>点击“测试”，创建一个线程，从0循环到10000给文本框赋值，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void btn_Test_Click(object sender, EventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            //创建一个线程去执行这个方法:创建的线程默认是前台线程</span><br><span class="line">            Thread thread = new Thread(new ThreadStart(Test));</span><br><span class="line">            //Start方法标记这个线程就绪了，可以随时被执行，具体什么时候执行这个线程，由CPU决定</span><br><span class="line">            //将线程设置为后台线程</span><br><span class="line">            thread.IsBackground = true;</span><br><span class="line">            thread.Start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void Test()</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10000; i++)</span><br><span class="line">            &#123;               </span><br><span class="line">                this.textBox1.Text = i.ToString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<img src="/2018-08-26/be08/2.51.JPG" title="抛出异常">
<blockquote>
<p>产生错误的原因：textBox1是由主线程创建的，thread线程是另外创建的一个线程，在.NET上执行的是托管代码，C#强制要求这些代码必须是线程安全的，即不允许跨线程访问Windows窗体的控件。</p>
</blockquote>
<p>解决方案：</p>
<ol>
<li>在窗体的加载事件中，将C#内置控件(Control)类的CheckForIllegalCrossThreadCalls属性设置为false，屏蔽掉C#编译器对跨线程调用的检查。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void Form1_Load(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">       //取消跨线程的访问</span><br><span class="line">       Control.CheckForIllegalCrossThreadCalls = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用上述的方法虽然可以保证程序正常运行并实现应用的功能，但是在实际的软件开发中，做如此设置是不安全的（不符合.NET的安全规范），在产品软件的开发中，此类情况是不允许的。如果要在遵守.NET安全标准的前提下，实现从一个线程成功地访问另一个线程创建的空间，要使用C#的方法回调机制。</p>
<ol start="2">
<li>使用回调函数</li>
</ol>
<p>回调实现的一般过程：</p>
<p> C#的方法回调机制，也是建立在委托基础上的，下面给出它的典型实现过程。</p>
<p>（1）、定义、声明回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//定义回调</span><br><span class="line">private delegate void DoSomeCallBack(Type para);</span><br><span class="line">//声明回调</span><br><span class="line">DoSomeCallBack doSomaCallBack;</span><br></pre></td></tr></table></figure>
<p>可以看出，这里定义声明的“回调”（doSomaCallBack）其实就是一个委托。</p>
<p>（2）、初始化回调方法。</p>
<p>doSomeCallBack=new DoSomeCallBack(DoSomeMethod);</p>
<p>所谓“初始化回调方法”实际上就是实例化刚刚定义了的委托，这里作为参数的DoSomeMethod称为“回调方法”，它封装了对另一个线程中目标对象（窗体控件或其他类）的操作代码。</p>
<p>（3）、触发对象动作</p>
<p>Opt  obj.Invoke(doSomeCallBack,arg);</p>
<p>其中Opt obj为目标操作对象，在此假设它是某控件，故调用其Invoke方法。Invoke方法签名为：</p>
<p>object  Control.Invoke(Delegate  method,params  object[] args);</p>
<p>它的第一个参数为委托类型，可见“触发对象动作”的本质，就是把委托doSomeCallBack作为参数传递给控件的Invoke方法，这与委托的使用方式是一模一样的。</p>
<p>最终作用于对象Opt obj的代码是置于回调方法体DoSomeMethod()中的，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void DoSomeMethod(type para)</span><br><span class="line">&#123;</span><br><span class="line">    //方法体</span><br><span class="line">    Opt obj.someMethod(para);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不用回调，而是直接在程序中使用“Opt obj.someMethod(para);”，则当对象Opt obj不在本线程（跨线程访问）时就会发生上面所示的错误。</p>
<p>从以上回调实现的一般过程可知：C#的回调机制，实质上是委托的一种应用。在C#网络编程中，回调的应用是非常普遍的，有了方法回调，就可以在.NET上写出线程安全的代码了。</p>
<p>使用方法回调，实现给文本框赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">namespace MultiThreadDemo</span><br><span class="line">&#123;</span><br><span class="line">    public partial class Form1 : Form</span><br><span class="line">    &#123;</span><br><span class="line">        public Form1()</span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line">        //定义回调</span><br><span class="line">        private delegate void setTextValueCallBack(int value);</span><br><span class="line">        //声明回调</span><br><span class="line">        private setTextValueCallBack setCallBack;</span><br><span class="line">        private void btn_Test_Click(object sender, EventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            //实例化回调</span><br><span class="line">            setCallBack = new setTextValueCallBack(SetValue);</span><br><span class="line">            //创建一个线程去执行这个方法:创建的线程默认是前台线程</span><br><span class="line">            Thread thread = new Thread(new ThreadStart(Test));</span><br><span class="line">            //Start方法标记这个线程就绪了，可以随时被执行，具体什么时候执行这个线程，由CPU决定</span><br><span class="line">            //将线程设置为后台线程</span><br><span class="line">            thread.IsBackground = true;</span><br><span class="line">            thread.Start();</span><br><span class="line">        &#125;</span><br><span class="line">        private void Test()</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10000; i++)</span><br><span class="line">            &#123;               </span><br><span class="line">                //使用回调</span><br><span class="line">                textBox1.Invoke(setCallBack, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 定义回调使用的方法</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;value&quot;&gt;&lt;/param&gt;</span><br><span class="line">        private void SetValue(int value)</span><br><span class="line">        &#123;</span><br><span class="line">            this.textBox1.Text = value.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h2><p>若想终止正在运行的线程，可以使用Abort()方法。</p>
<h1 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h1><p>同步和异步是对方法执行顺序的描述。</p>
<p>同步：等待上一行完成计算之后，才会进入下一行。</p>
<p>例如：请同事吃饭，同事说很忙，然后就等着同事忙完，然后一起去吃饭。</p>
<p>异步：不会等待方法的完成，会直接进入下一行，是非阻塞的。</p>
<p>例如：请同事吃饭，同事说很忙，那同事先忙，自己去吃饭，同事忙完了他自己去吃饭。</p>
<p>下面通过一个例子讲解同步和异步的区别</p>
<p>1、新建一个winform程序，上面有两个按钮，一个同步方法、一个异步方法，在属性里面把输出类型改成控制台应用程序，这样可以看到输出结果，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.ComponentModel;</span><br><span class="line">using System.Data;</span><br><span class="line">using System.Drawing;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line">using System.Windows.Forms;</span><br><span class="line"></span><br><span class="line">namespace MyAsyncThreadDemo</span><br><span class="line">&#123;</span><br><span class="line">    public partial class Form1 : Form</span><br><span class="line">    &#123;</span><br><span class="line">        public Form1()</span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 异步方法</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt;</span><br><span class="line">        private void btnAsync_Click(object sender, EventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine($&quot;***************btnAsync_Click Start &#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;);</span><br><span class="line">            Action&lt;string&gt; action = this.DoSomethingLong;</span><br><span class="line">            // 调用委托(同步调用)</span><br><span class="line">            action.Invoke(&quot;btnAsync_Click_1&quot;);</span><br><span class="line">            // 异步调用委托</span><br><span class="line">            action.BeginInvoke(&quot;btnAsync_Click_2&quot;,null,null);</span><br><span class="line">            Console.WriteLine($&quot;***************btnAsync_Click End    &#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 同步方法</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt;</span><br><span class="line">        private void btnSync_Click(object sender, EventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine($&quot;****************btnSync_Click Start &#123;Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)&#125; &#123;DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss.fff&quot;)&#125;***************&quot;);</span><br><span class="line">            int j = 3;</span><br><span class="line">            int k = 5;</span><br><span class="line">            int m = j + k;</span><br><span class="line">            for (int i = 0; i &lt; 5; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                string name = string.Format($&quot;btnSync_Click_&#123;i&#125;&quot;);</span><br><span class="line">                this.DoSomethingLong(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        private void DoSomethingLong(string name)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine($&quot;****************DoSomethingLong &#123;name&#125; Start &#123;Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)&#125; &#123;DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss.fff&quot;)&#125;***************&quot;);</span><br><span class="line">            long lResult = 0;</span><br><span class="line">            for (int i = 0; i &lt; 1000000000; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                lResult += i;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine($&quot;****************DoSomethingLong &#123;name&#125;   End &#123;Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)&#125; &#123;DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss.fff&quot;)&#125; &#123;lResult&#125;***************&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2018-08-26/be08/31.JPG" title="同步">
<p>从上面的截图中能够很清晰的看出：同步方法是等待上一行代码执行完毕之后才会执行下一行代码。</p>
<img src="/2018-08-26/be08/32.JPG" title="异步">
<p>从上面的截图中看出：当执行到action.BeginInvoke(“btnAsync_Click_2”,null,null);这句代码的时候，程序并没有等待这段代码执行完就执行了下面的End，没有阻塞程序的执行。</p>
<p>在刚才的测试中，如果点击同步，这时winform界面不能拖到，界面卡住了，是因为主线程(即UI线程)在忙于计算。</p>
<p>点击异步的时候，界面不会卡住，这是因为主线程已经结束，计算任务交给子线程去做。</p>
<p>在仔细检查上面两个截图，可以看出异步的执行速度比同步执行速度要快。同步方法执行完将近16秒，异步方法执行完将近6秒。</p>
<p>在看下面的一个例子，修改异步的方法，也和同步方法一样执行循环，修改后的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void btnAsync_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">      Console.WriteLine($&quot;***************btnAsync_Click Start &#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;);</span><br><span class="line">      //Action&lt;string&gt; action = this.DoSomethingLong;</span><br><span class="line">      //// 调用委托(同步调用)</span><br><span class="line">      //action.Invoke(&quot;btnAsync_Click_1&quot;);</span><br><span class="line">      //// 异步调用委托</span><br><span class="line">      //action.BeginInvoke(&quot;btnAsync_Click_2&quot;,null,null);</span><br><span class="line">      Action&lt;string&gt; action = this.DoSomethingLong;</span><br><span class="line">      for (int i = 0; i &lt; 5; i++)</span><br><span class="line">      &#123;</span><br><span class="line">           //Thread.Sleep(5);</span><br><span class="line">           string name = string.Format($&quot;btnAsync_Click_&#123;i&#125;&quot;);</span><br><span class="line">           action.BeginInvoke(name, null, null);</span><br><span class="line">      &#125;</span><br><span class="line">      Console.WriteLine($&quot;***************btnAsync_Click End    &#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <img src="/2018-08-26/be08/33.JPG" title="运行结果">
<p>从截图中能够看出：同步方法执行是有序的，异步方法执行是无序的。异步方法无序包括启动无序和结束无序。启动无序是因为同一时刻向操作系统申请线程，操作系统收到申请以后，返回执行的顺序是无序的，所以启动是无序的。结束无序是因为虽然线程执行的是同样的操作，但是每个线程的耗时是不同的，所以结束的时候不一定是先启动的线程就先结束。从上面同步方法中可以清晰的看出：btnSync_Click_0执行时间耗时不到3秒，而btnSync_Click_1执行时间耗时超过了3秒。可以想象体育比赛中的跑步，每位运动员听到发令枪起跑的顺序不同，每位运动员花费的时间不同，最终到达终点的顺序也不同。</p>
<p>总结一下同步方法和异步方法的区别：</p>
<p>1、同步方法由于主线程忙于计算，所以会卡住界面。</p>
<pre><code>异步方法由于主线程执行完了，其他计算任务交给子线程去执行，所以不会卡住界面，用户体验性好。
</code></pre><p>2、同步方法由于只有一个线程在计算，所以执行速度慢。</p>
<pre><code>异步方法由多个线程并发运算，所以执行速度快，但并不是线性增长的（资源可能不够）。多线程也不是越多越好，只有多个独立的任务同时运行，才能加快速度。
</code></pre><p>3、同步方法是有序的。</p>
<pre><code>异步多线程是无序的：启动无序，执行时间不确定，所以结束也是无序的。一定不要通过等待几毫秒的形式来控制线程启动/执行时间/结束。
</code></pre><h1 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h1><p>先来看看异步多线程无序的例子：</p>
<p>在界面上新增一个按钮，实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void btnAsyncAdvanced_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">      Console.WriteLine($&quot;****************btnAsyncAdvanced_Click Start &#123;Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)&#125; &#123;DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss.fff&quot;)&#125;***************&quot;);</span><br><span class="line">      Action&lt;string&gt; action = this.DoSomethingLong;</span><br><span class="line">      action.BeginInvoke(&quot;btnAsyncAdvanced_Click&quot;, null, null);</span><br><span class="line">      // 需求：异步多线程执行完之后再打印出下面这句</span><br><span class="line">      Console.WriteLine($&quot;到这里计算已经完成了。&#123;Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)&#125;。&quot;);</span><br><span class="line">      Console.WriteLine($&quot;****************btnAsyncAdvanced_Click End &#123;Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)&#125; &#123;DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss.fff&quot;)&#125;***************&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2018-08-26/be08/41.JPG" title="运行结果">
<p>从上面的截图中看出，最终的效果并不是我们想要的效果，而且打印输出的还是主线程。</p>
<p>既然异步多线程是无序的，那我们有没有什么办法可以解决无序的问题呢？办法当然是有的，那就是使用回调，.NET框架已经帮我们实现了回调：</p>
<img src="/2018-08-26/be08/42.JPG" title="运行结果">
<p>BeginInvoke的第二个参数就是一个回调，那么AsyncCallback究竟是什么呢？F12查看AsyncCallback的定义</p>
<p>发现AsyncCallback就是一个委托，参数类型是IAsyncResult，明白了AsyncCallback是什么以后，将上面的代码进行如下的改造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void btnAsyncAdvanced_Click(object sender, EventArgs e)</span><br><span class="line">&#123;       </span><br><span class="line">    Console.WriteLine($&quot;****************btnAsyncAdvanced_Click Start &#123;Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)&#125; &#123;DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss.fff&quot;)&#125;***************&quot;);</span><br><span class="line">    Action&lt;string&gt; action = this.DoSomethingLong;</span><br><span class="line">    // 定义一个回调</span><br><span class="line">    AsyncCallback callback = p =&gt; </span><br><span class="line">    &#123;</span><br><span class="line">       Console.WriteLine($&quot;到这里计算已经完成了。&#123;Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)&#125;。&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    // 回调作为参数</span><br><span class="line">    action.BeginInvoke(&quot;btnAsyncAdvanced_Click&quot;, callback, null);          </span><br><span class="line">    Console.WriteLine($&quot;****************btnAsyncAdvanced_Click End &#123;Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)&#125; &#123;DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss.fff&quot;)&#125;***************&quot;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<img src="/2018-08-26/be08/43.JPG" title="运行结果">
<p>上面的截图中可以看出，这就是我们想要的效果，而且打印是子线程输出的，但是程序究竟是怎么实现的呢？我们可以进行如下的猜想：</p>
<p>程序执行到BeginInvoke的时候，会申请一个基于线程池的线程，这个线程会完成委托的执行(在这里就是执行DoSomethingLong()方法)，在委托执行完以后，这个线程又会去执行callback回调的委托，执行callback委托需要一个IAsyncResult类型的参数，这个IAsyncResult类型的参数是如何来的呢？鼠标右键放到BeginInvoke上面，查看返回值</p>
<p>发现BeginInvoke的返回值就是IAsyncResult类型的。那么这个返回值是不是就是callback委托的参数呢？将代码进行如下的修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void btnAsyncAdvanced_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">            // 需求：异步多线程执行完之后再打印出下面这句</span><br><span class="line">            Console.WriteLine($&quot;****************btnAsyncAdvanced_Click Start &#123;Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)&#125; &#123;DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss.fff&quot;)&#125;***************&quot;);</span><br><span class="line">            Action&lt;string&gt; action = this.DoSomethingLong;</span><br><span class="line">            // 无序的</span><br><span class="line">            //action.BeginInvoke(&quot;btnAsyncAdvanced_Click&quot;, null, null);</span><br><span class="line"></span><br><span class="line">            IAsyncResult asyncResult = null;</span><br><span class="line">            // 定义一个回调</span><br><span class="line">            AsyncCallback callback = p =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                // 比较两个变量是否是同一个</span><br><span class="line">                Console.WriteLine(object.ReferenceEquals(p,asyncResult));</span><br><span class="line">                Console.WriteLine($&quot;到这里计算已经完成了。&#123;Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)&#125;。&quot;);</span><br><span class="line">            &#125;;</span><br><span class="line">            // 回调作为参数</span><br><span class="line">            asyncResult= action.BeginInvoke(&quot;btnAsyncAdvanced_Click&quot;, callback, null);           </span><br><span class="line">            Console.WriteLine($&quot;****************btnAsyncAdvanced_Click End &#123;Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)&#125; &#123;DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss.fff&quot;)&#125;***************&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2018-08-26/be08/44.JPG" title="运行结果">
<p>这里可以看出BeginInvoke的返回值就是callback委托的参数。</p>
<p>现在我们可以使用回调解决异步多线程无序的问题了。</p>
<p>2、获取委托异步调用的返回值</p>
<p>使用EndInvoke可以获取委托异步调用的返回值，请看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void btnAsyncReturnVlaue_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">       // 定义一个无参数、int类型返回值的委托</span><br><span class="line">       Func&lt;int&gt; func = () =&gt;</span><br><span class="line">       &#123;</span><br><span class="line">             Thread.Sleep(2000);</span><br><span class="line">             return DateTime.Now.Day;</span><br><span class="line">       &#125;;</span><br><span class="line">       // 输出委托同步调用的返回值</span><br><span class="line">       Console.WriteLine($&quot;func.Invoke()=&#123;func.Invoke()&#125;&quot;);</span><br><span class="line">       // 委托的异步调用</span><br><span class="line">       IAsyncResult asyncResult = func.BeginInvoke(p =&gt; </span><br><span class="line">       &#123;</span><br><span class="line">            Console.WriteLine(p.AsyncState);</span><br><span class="line">       &#125;,&quot;异步调用返回值&quot;);</span><br><span class="line">       // 输出委托异步调用的返回值</span><br><span class="line">       Console.WriteLine($&quot;func.EndInvoke(asyncResult)=&#123;func.EndInvoke(asyncResult)&#125;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2018-08-26/be08/45.JPG" title="运行结果">

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C#</a>
          
            <a href="/tags/线程/" rel="tag"><i class="fa fa-tag"></i> 线程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018-07-05/4ba9.html" rel="next" title="VisualStudio2017 扩展插件">
                <i class="fa fa-chevron-left"></i> VisualStudio2017 扩展插件
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018-09-02/64ac.html" rel="prev" title="Git与SSH">
                Git与SSH <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNTk4NS8xMjUyMQ"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/poet.jpg"
                alt="Rocinante-Poet" />
            
              <p class="site-author-name" itemprop="name">Rocinante-Poet</p>
              <p class="site-description motion-element" itemprop="description">诗人和祂的驽骍难得</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/3017932712?is_all=1" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://telegram.me/Poet_IIII" target="_blank" title="Telegram">
                      
                        <i class="fa fa-fw fa-telegram"></i>Telegram</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:Poet515@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基本概念"><span class="nav-number">1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多线程"><span class="nav-number">2.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#System-Threading-Thread类"><span class="nav-number">2.1.</span> <span class="nav-text">System.Threading.Thread类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的常用属性"><span class="nav-number">2.2.</span> <span class="nav-text">线程的常用属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的标识符"><span class="nav-number">2.2.1.</span> <span class="nav-text">线程的标识符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的优先级别"><span class="nav-number">2.2.2.</span> <span class="nav-text">线程的优先级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的状态"><span class="nav-number">2.2.3.</span> <span class="nav-text">线程的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#System-Threading-Thread的方法"><span class="nav-number">2.2.4.</span> <span class="nav-text">System.Threading.Thread的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前台线程和后台线程"><span class="nav-number">2.3.</span> <span class="nav-text">前台线程和后台线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程同步"><span class="nav-number">2.4.</span> <span class="nav-text">线程同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跨线程访问"><span class="nav-number">2.5.</span> <span class="nav-text">跨线程访问</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#终止线程"><span class="nav-number">2.6.</span> <span class="nav-text">终止线程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#同步和异步"><span class="nav-number">3.</span> <span class="nav-text">同步和异步</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#回调"><span class="nav-number">4.</span> <span class="nav-text">回调</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rocinante-Poet</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>

    
      <span class="post-meta-item-text">博客全站字数&#58;</span>
    
    <span title="博客全站字数">45.3k</span>
  
  <span class="post-meta-divider">|</span><span>Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>
</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/love.js"></script>
